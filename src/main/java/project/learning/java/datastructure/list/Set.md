## Java 컬렉션: 해시 (Hash)와 Set 자료구조 

**Set 자료구조**의 개념과 **해시 알고리즘**을 통한 성능 개선 원리, 그리고 주요 Set 구현체들(`HashSet`, `LinkedHashSet`, `TreeSet`)


---

## 1.  List vs Set (자료구조 정의)

| 구분 | List (리스트) | Set (세트) |
| :--- | :--- | :--- |
| **순서** | **순서 유지** (인덱스 접근 가능) | **순서 미보장** (대부분, 저장 순서에 의존하지 않음) |
| **중복** | **중복 허용** | **유일성** (중복 허용 안 함) |
| **검색 성능** | $O(n)$ (순차 탐색) | **평균 $O(1)$** (해시 알고리즘 사용) |
| **주요 용도** | 순서가 중요하거나 중복이 필요한 경우 (장바구니) | 중복 없이 요소의 유무만 중요한 경우 (회원 ID 집합) |

---

## 2. 해시 알고리즘의 원리와 성능 개선
컬렉션에서 데이터의 중복을 확인하기 위해서는 순차 순회를 한다. 최약의 경우 모든 데이터를 다 확인해야 하므로 $O(n)$의 성능이 소요된다.

Set 자료구조에서 중복 검사 시, 데이터 추가/검색 시 발생하는 $O(n)$ 성능 문제를 $O(1)$로 개선하기 위해 해시 알고리즘을 사용합니다.

### 2.1. 해시 알고리즘의 핵심 아이디어

* **배열의 인덱스 활용:** 배열은 인덱스를 사용해 $O(1)$로 빠르게 접근할 수 있다는 특징을 이용합니다.
* **데이터 값 = 인덱스:** 데이터의 **값 자체**를 배열의 **인덱스**로 사용하여, 값을 찾을 때 순차 탐색 없이 한 번에 접근합니다.
    * 예: 데이터 값이 `5`라면, 배열의 `index 5`에 해당 데이터를 저장/조회합니다.

### 2.2. 메모리 낭비 문제와 해결책 (나머지 연산)


* **문제:** 데이터의 값 범위가 넓을수록 (예: `int` 범위) 배열의 크기가 매우 커져 메모리가 낭비됩니다.
* **해결:** **나머지 연산 (`% CAPACITY`)**을 사용합니다.
    * **해시 함수:** 데이터를 입력받아 **해시 코드(정수)**를 만듭니다. (예: 문자열을 숫자로 변환)
    * **해시 인덱스:** 해시 코드를 배열 크기(`CAPACITY`)로 나눈 **나머지 값**을 배열의 인덱스로 사용합니다.
    * **결과:** 넓은 범위의 데이터 값도 제한된 배열 크기 내의 인덱스(0 ~ CAPACITY-1)로 변환되어 메모리 낭비를 줄이고 $O(1)$ 성능을 유지합니다.

### 2.3. 해시 충돌과 해결


* **해시 충돌:** 서로 **다른 데이터**가 **같은 해시 인덱스**를 가지는 현상 (예: $1 \% 10 = 1$, $11 \% 10 = 1$).
* **해결 방법 (체이닝, Chaining):**
    * 배열의 각 인덱스(버킷)에 리스트 자료구조를 연결하여, 충돌된 모든 데이터를 그 리스트에 함께 저장합니다.
* **성능 분석:**
    * **평균:** 해시 충돌이 적절히 제어되면, 데이터 저장/조회는 $O(1)$에 가깝습니다.
    * **최악:** 모든 데이터가 한 버킷에 몰리면 (해시 충돌이 극심할 경우), 해당 버킷의 연결 리스트를 순차 탐색해야 하므로 $O(n)$ 성능이 됩니다.

---

## 3.  `equals()`와 `hashCode()`의 중요성 (필수 구현)

해시 자료구조(`HashSet`)를 사용할 때, **논리적으로 동등한 객체**를 올바르게 처리하기 위해 **`hashCode()`**와 **`equals()`** 메서드를 반드시 함께 재정의해야 합니다.

| 메서드 | 역할                                  | 실패 시 문제 |
| :--- |:------------------------------------| :--- |
| **`hashCode()`** | 논리적으로 동등한 객체는 **같은 해시 코드**를 반환해야 함. | **데이터 저장 실패:** 해시 코드가 다르면 데이터가 다른 인덱스에 저장되어 **중복 허용** (Set의 목적 위배). |
| **`equals()`** | 논리적으로 동등한 객체는 `true`를 반환해야 함.     | **데이터 검색 실패:** 해시 코드가 같아도 $equals$가 $false$면 같은 객체로 인식하지 못하여 **검색 실패**. |

> **원칙:** `equals()`가 `true`를 반환하는 두 객체는 반드시 **같은 `hashCode()` 값**을 반환해야 합니다.

참고로 동등성을 확인할 때, hashCode() -> equals() 순서로 호출됩니다. 따라서 hashCode() 오버라이딩은 필수다. 만약 재정의하지 않으면 기존 참조값에 대한 해시코드가 반영되기에 논리적 동등 객체가 다른 해시코드를 가지게 된다.

---

## 4. Java Set 구현체 비교

Java Collection Framework는 Set 인터페이스를 구현하는 세 가지 주요 클래스를 제공하며, 각각 다른 용도에 최적화되어 있습니다.

| 클래스 | 내부 구현 | 순서 보장 | 주요 연산 시간 복잡도 | 용도 |
| :--- | :--- | :--- | :--- | :--- |
| **`HashSet`** | 해시 테이블 | **X** (순서 미보장) | **평균 $O(1)$** | 가장 빠름. 순서와 정렬이 필요 없을 때 기본으로 사용. |
| **`LinkedHashSet`** | 해시 테이블 + 연결 리스트 | **O** (삽입 순서 보장) | **평균 $O(1)$** | 삽입 순서를 유지해야 할 때 사용. |
| **`TreeSet`** | 레드-블랙 트리 (균형 이진 탐색 트리) | **O** (데이터 값 기준 정렬) | **$O(\log n)$** | 데이터 정렬이 필요할 때 사용. `HashSet`보다 느림. |

### 4.1. `HashSet`의 최적화 (재해싱, Rehashing)

* **로드 팩터 (Load Factor):** 데이터 수가 배열 크기(`CAPACITY`)의 75%를 넘으면 해시 충돌 가능성이 높아집니다.
* **재해싱:** Java `HashSet`은 로드 팩터가 75%를 초과하면 **배열 크기를 2배**로 늘리고, **모든 데이터의 해시 인덱스를 새 배열 크기에 맞춰 다시 계산**하여 해시 충돌 확률을 낮추고 $O(1)$ 성능을 유지합니다.
