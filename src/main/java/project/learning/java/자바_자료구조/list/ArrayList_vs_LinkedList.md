## Java `List` 성능 비교(ArrayList vs LinkedList)

`ArrayList`와 `LinkedList`의 성능 비교, 그리고 깨알로 구현체 대신 인터페이스를 사용해야 하는 이유(OCP)에 대해 정리한 README 문서입니다.

-----

## 1\. 인터페이스(`List`) 사용의 중요성: 개방-폐쇄 원칙 (OCP)

Java Collection Framework에서 `ArrayList`나 `LinkedList`와 같은 **구체 클래스**를 직접 사용하는 대신, **`List` 인터페이스**를 사용해야 하는 것이 **객체 지향 설계**의 핵심 원칙 중 하나인 개방-폐쇄 원칙(Open-Closed Principle, OCP)입니다.

* **OCP 정의:** 코드는 **확장에는 개방적**이어야 하지만, **변경에는 폐쇄적**이어야 합니다.
* **List 인터페이스 사용 이유:**
    * **확장성:** 코드를 `List` 인터페이스에 의존하게 만들면, 나중에 성능상의 이유로 `ArrayList`를 `LinkedList`로, 혹은 그 반대로 변경해야 할 때, **변수 선언부만 수정**하면 됩니다.
    * **폐쇄성:** 메서드나 비즈니스 로직은 `List` 인터페이스에 정의된 메서드만 사용하므로, 내부 구현체가 변경되어도 **로직 코드를 수정할 필요가 없습니다.**

<!-- end list -->

```java
void method(ArrayList<Integer> list) {
  // 위 리스트에는 100만 개의 원소가 들어있다고 가정 
  for (int i = 0; i < 1_000_000; i++)
      list.remove(0);
}
```
위와 같은 로직이 있을때, 원소를 삭제하는 건 O(N)이 소요된다. 따라서 ArrayList 대신 LinkedList를 사용하면 성능이 개선될 수 있다. 하지만 위 코드처럼 ArrayList로 고정되어 있다면, LinkedList로 변경하려면 메서드 시그니처부터 바꿔야 한다. 
반면에 아래와 같이 List 인터페이스를 사용하면, 내부 구현체만 바꾸면 된다.
(이론적으로)
-----

## 2\.️ ArrayList vs LinkedList 성능 비교 분석
예시로 [N개 데이터가 있을 때, 중간 추가/삭제의 경우]를 고민해보면 ArrayList는 인덱스로 해당 위치에 접근하기에 O(1), 이후 삽입/삭제는 뒤에 있는 모든 원소를 한 칸씩 밀거나 당기기에 O(N/2)이 소요된다. 
반면에 LinkedList는 노드를 찾는데 O(N/2), 노드의 참조만 변경하는 데 O(1)이 소요된다. 
둘다 O(N) 으로 예상되지만 아래 측정 결과와 같이 618ms vs 1032ms로 ArrayList가 더 빠른 결과가 나왔다. 왜 그럴까?

| 기능 | 자료구조 | 시간 복잡도 | ArrayList | LinkedList               |
| :--- | :--- | :--- |:------------------------|:-------------------------|
| **중간 추가/삭제** | (배열 이동) / (노드 순회) | $O(n)$ / $O(n)$ | 618ms                   | 1032ms                   |


-----

## 3\. 이론에 비해 `ArrayList`가 더 빠른 이유

주목할 점은, 중간 추가/삭제 연산의 시간 복잡도가 이론적으로는 `LinkedList`가 유리하거나 비슷하게 느껴질 수도 있지만, 실제로는 `ArrayList`가 더 좋은 성능을 보인다는 것입니다.

### 1\. CPU 캐시 효율성 (Cache Locality)

* **`ArrayList`:** 요소들이 **메모리 상에 연속적으로** 위치합니다. 데이터 접근 시, CPU 캐시에 한 번에 많은 데이터가 로드되어 캐시 히트율(Cache Hit Rate)이 높습니다. 이는 순차적인 접근이나 조회 연산에서 엄청난 속도 이득을 가져옵니다.
* **`LinkedList`:** 각 요소(노드)가 메모리의 **분산된 위치**에 존재하며, 다음 요소의 주소(참조)를 저장합니다. 따라서 데이터를 읽을 때마다 메모리의 여러 곳을 참조해야 하므로 **CPU 캐시 효율이 떨어지고**, 메모리 접근 속도가 상대적으로 느립니다.

### 2\. 최적화된 배열 복사

* `ArrayList`의 중간 삽입/삭제 시 발생하는 배열 요소 이동은 Java 내부에서 `System.arraycopy()`와 같은 네이티브 코드(Native Code)를 사용한 **메모리 고속 복사 연산**으로 최적화되어 있습니다. 이 고속 복사 연산이 `LinkedList`의 노드 순회 비용보다 실제로는 더 빠를 수 있습니다.

### 3\. 결론

대부분의 경우 조회와 데이터 순회(검색)가 프로그램에서 가장 빈번하게 일어나며, 이러한 연산에서 **`ArrayList`의 CPU 캐시 효율성**이 압도적인 성능 우위를 제공합니다.

* **실무 권장:** 데이터의 **앞쪽에서 빈번하게 추가/삭제**하는 특별한 경우가 아니라면, **`ArrayList`를 기본 구현체**로 사용하는 것이 일반적이며 성능상 유리합니다.

-----
 짧은 코드, 변수명, 시간 복잡도($O(n)$ 등)를 표시합니다. |